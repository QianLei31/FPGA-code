//************************************************************************************
//************************************************************************************
// Company          : X-FAB Global Services GmbH
// Address          : Haarbergstr. 67,  D-99097 Erfurt, Germany
//
// File             : D_CELLS_HDLL.v
// Description      : Verilog model file for Library D_CELLS_HDLL
//                  : with negative timing check support; 
//                  : X-FAB XT018 Digital Standard Cell Logic Library,
//                  : 1.8V, 1.2V Low Leakage & Low Power, High Density routing pitch
//                 
// Technology       : XT018 - 180 nm HV SOI CMOS
//
// Lib_version      : 1.3.0, Tue Apr 28 06:14:57 CEST 2020
//
// Created by       : X-FAB Library Processor XLIB_PROC 
// Program version  : XLIB_PROC - xlib_proc, v1.0.0 build 53 Time stamp: Apr 15 2020 10:15:05
// Last Modified by : XLIB_PROC generated
//
// ######################################################################################
//
// Copyright (c) X-FAB Global Services GmbH. All rights reserved.
// This Design Kit data and the associated documentation are
// confidential and proprietary to X-FAB Global Services GmbH.
//
// DISCLAIMER
// The information furnished herein by X-FAB Global Services GmbH (X-FAB) 
// is substantially correct and accurate. However, X-FAB shall not be 
// liable to licensee or any third party for any damages, including but 
// not limited to property damage, loss of profits, loss of use, 
// interruption of business or indirect, special, incidental or 
// consequential damages, of any kind, in connection with or arising out 
// of the furnishing, performance or use of the technical data. 
// No obligation or liability to licensee or any third party shall arise 
// or flow out of X-FAB rendering technical or other services.
// 
// X-FAB makes no warranty, express, implied, statutory, or descriptive 
// of the information contained herein or of warranties of 
// merchantability, fitness for a particular purpose, or non-infringement.
// X-FAB reserves the right to change specifications and prices at any 
// time and without notice. Therefore, prior to designing this product 
// into a system, it is necessary to check with X-FAB for current 
// information. The products listed herein are intended for use in 
// standard commercial applications. Applications requiring extended 
// temperature range, unusual environmental requirements, or high 
// reliability applications, such as military, medical life-support 
// or life-sustaining equipment are specifically not recommended without 
// additional processing by X-FAB for each application.
//
// ######################################################################################
// 
// Remark:
// 
// This Verilog library uses  User Defined Primitives (UDP)
// which are defined in the Verilog library file VLG_PRIMITIVES.v.
//
// If an ATPG tool is used then the compiler directive 
//   `define ATPG_RUN yes
// has to be set before reading this library.
// 
// Use the compiler directive command
//   `define  DISPLAY_HOLD yes
// to enable the logic pullup/down behaviour of the Leakage current 
// compensator cell SIGNALHOLD* (see also the comment in the SIGNALHOLD* 
// cell model)
// 
// Use the compiler directive command
//   `define  NEG_TCHK yes
// to enable the syntax support for negative timing checks. 
//
//************************************************************************/

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN211HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN211HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN211HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN211HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN211HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN211HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN211HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN211HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN21HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN21HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN21HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN21HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN21HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN21HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN21HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN21HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN221HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN221HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN221HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN221HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN221HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN221HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN221HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN221HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN222HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN222HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN222HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN222HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN222HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN222HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN222HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN222HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN22HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN22HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN22HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN22HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN22HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN22HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN22HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN22HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN311HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN311HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN311HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN311HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN311HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN311HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN311HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN311HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN31HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN31HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN31HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN31HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN31HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN31HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN31HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN31HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN321HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN321HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN321HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN321HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN321HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN321HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN321HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN321HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN32HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN32HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN32HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN32HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN32HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN32HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN32HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN32HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN33HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN33HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN33HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN33HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN33HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN33HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AN33HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AN33HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND2HDLLX0 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND2HDLLX1 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND2HDLLX2 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND2HDLLX4 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND3HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND3HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND3HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND3HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND4HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND4HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND4HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND4HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND5HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND5HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND5HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND5HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND5HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND5HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND5HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND5HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND6HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND6HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND6HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND6HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND6HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND6HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AND6HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AND6HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO211HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO211HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO211HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO211HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO211HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO211HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO211HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO211HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO21HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO21HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO21HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO21HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO21HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO21HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO21HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO21HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO221HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO221HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO221HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO221HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO221HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO221HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO221HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO221HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO222HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO222HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO222HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO222HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO222HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO222HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO222HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO222HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO22HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO22HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO22HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO22HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO22HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO22HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO22HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO22HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO311HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO311HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO311HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO311HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO311HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO311HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO311HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO311HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO31HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO31HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO31HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO31HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO31HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO31HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO31HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO31HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO321HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO321HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO321HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO321HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO321HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO321HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO321HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO321HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO32HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO32HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO32HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO32HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO32HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO32HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO32HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO32HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO33HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO33HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO33HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO33HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO33HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO33HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : AO33HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module AO33HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX12
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX12 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX1 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX2 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX3
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX3 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX4 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX6
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX6 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTHHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTHHDLLX8 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX12
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX12 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX1 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX2 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX3
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX3 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX4 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX6
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX6 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BTLHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BTLHDLLX8 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX0 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX12
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX12 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX1 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX2 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX3
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX3 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX4 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX6
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX6 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : BUHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module BUHDLLX8 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : CAGHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

module CAGHDLLX0 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : CAGHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

module CAGHDLLX1 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : CAGHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

module CAGHDLLX2 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : CAGHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

module CAGHDLLX4 (A, B, CI, CO);

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFHDLLX0 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFHDLLX1 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFHDLLX2 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFHDLLX4 (CN, D, Q, QN);

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFQHDLLX0 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFQHDLLX1 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFQHDLLX2 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFQHDLLX4 (CN, D, Q);

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRHDLLX0 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRHDLLX1 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRHDLLX2 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRHDLLX4 (CN, D, Q, QN, RN);

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRQHDLLX0 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRQHDLLX1 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRQHDLLX2 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRQHDLLX4 (CN, D, Q, RN);

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSHDLLX0 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSHDLLX1 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSHDLLX2 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSHDLLX4 (CN, D, Q, QN, RN, SN);

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSQHDLLX0 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSQHDLLX1 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSQHDLLX2 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFRSQHDLLX4 (CN, D, Q, RN, SN);

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSHDLLX0 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSHDLLX1 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSHDLLX2 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSHDLLX4 (CN, D, Q, QN, SN);

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSQHDLLX0 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSQHDLLX1 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSQHDLLX2 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFFSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFFSQHDLLX4 (CN, D, Q, SN);

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFR2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFR2HDLLX1 (C, D0, D1, Q0, Q1, QN0, QN1);

   input     C, D0, D1;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFR2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFR2HDLLX2 (C, D0, D1, Q0, Q1, QN0, QN1);

   input     C, D0, D1;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFR4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFR4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3);

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFR4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFR4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3);

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFR8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFR8HDLLX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFR8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFR8HDLLX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRHDLLX0 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRHDLLX1 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRHDLLX2 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRHDLLX4 (C, D, Q, QN);

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQ2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQ2HDLLX1 (C, D0, D1, Q0, Q1);

   input     C, D0, D1;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQ2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQ2HDLLX2 (C, D0, D1, Q0, Q1);

   input     C, D0, D1;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQ4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQ4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3);

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQ4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQ4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3);

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQ8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQ8HDLLX1 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQ8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQ8HDLLX2 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQHDLLX0 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQHDLLX1 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQHDLLX2 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRQHDLLX4 (C, D, Q);

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRR2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRR2HDLLX1 (C, D0, D1, Q0, Q1, QN0, QN1, RN);

   input     C, D0, D1, RN;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRR2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRR2HDLLX2 (C, D0, D1, Q0, Q1, QN0, QN1, RN);

   input     C, D0, D1, RN;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRR4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRR4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN);

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRR4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRR4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN);

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRR8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRR8HDLLX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRR8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRR8HDLLX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRHDLLX0 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRHDLLX1 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRHDLLX2 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRHDLLX4 (C, D, Q, QN, RN);

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQ2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQ2HDLLX1 (C, D0, D1, Q0, Q1, RN);

   input     C, D0, D1, RN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQ2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQ2HDLLX2 (C, D0, D1, Q0, Q1, RN);

   input     C, D0, D1, RN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQ4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQ4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN);

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQ4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQ4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN);

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQ8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQ8HDLLX1 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQ8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQ8HDLLX2 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQHDLLX0 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQHDLLX1 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQHDLLX2 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRQHDLLX4 (C, D, Q, RN);

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSHDLLX0 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSHDLLX1 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSHDLLX2 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSHDLLX4 (C, D, Q, QN, RN, SN);

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSQHDLLX0 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSQHDLLX1 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSQHDLLX2 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRRSQHDLLX4 (C, D, Q, RN, SN);

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSHDLLX0 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSHDLLX1 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSHDLLX2 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSHDLLX4 (C, D, Q, QN, SN);

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSQHDLLX0 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSQHDLLX1 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSQHDLLX2 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DFRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DFRSQHDLLX4 (C, D, Q, SN);

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHHDLLX0 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHHDLLX1 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHHDLLX2 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHHDLLX4 (D, G, Q, QN);

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHQHDLLX0 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHQHDLLX1 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHQHDLLX2 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHQHDLLX4 (D, G, Q);

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRHDLLX0 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRHDLLX1 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRHDLLX2 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRHDLLX4 (D, G, Q, QN, RN);

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRQHDLLX0 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRQHDLLX1 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRQHDLLX2 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRQHDLLX4 (D, G, Q, RN);

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSHDLLX0 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSHDLLX1 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSHDLLX2 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSHDLLX4 (D, G, Q, QN, RN, SN);

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSQHDLLX0 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSQHDLLX1 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSQHDLLX2 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRSQHDLLX4 (D, G, Q, RN, SN);

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHRTHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with reset; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHRTHDLLX1 (D, EN, G, Q, RN);

   input     D, EN, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSHDLLX0 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSHDLLX1 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSHDLLX2 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSHDLLX4 (D, G, Q, QN, SN);

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSQHDLLX0 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSQHDLLX1 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSQHDLLX2 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSQHDLLX4 (D, G, Q, SN);

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHSTHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch with set; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHSTHDLLX1 (D, EN, G, Q, SN);

   input     D, EN, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLHTHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : high active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLHTHDLLX1 (D, EN, G, Q);

   input     D, EN, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLHDLLX0 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLHDLLX1 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLHDLLX2 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLHDLLX4 (D, GN, Q, QN);

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLQHDLLX0 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLQHDLLX1 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLQHDLLX2 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLQHDLLX4 (D, GN, Q);

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRHDLLX0 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRHDLLX1 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRHDLLX2 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRHDLLX4 (D, GN, Q, QN, RN);

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRQHDLLX0 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRQHDLLX1 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRQHDLLX2 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRQHDLLX4 (D, GN, Q, RN);

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSHDLLX0 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSHDLLX1 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSHDLLX2 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSHDLLX4 (D, GN, Q, QN, RN, SN);

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSQHDLLX0 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSQHDLLX1 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSQHDLLX2 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRSQHDLLX4 (D, GN, Q, RN, SN);

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRT2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit low active transparent D-latch with reset; tristate Q Buffer with active low 
//   enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRT2HDLLX1 (D0, D1, EN, GN, Q0, Q1, RN);

   input     D0, D1, EN, GN, RN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, delay_GN, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, delay_RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, delay_RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);
	checkrs	i7 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);
	checkrs	i7 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRT4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit low active transparent D-latch with reset; tristate Q Buffer with active low 
//   enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRT4HDLLX1 (D0, D1, D2, D3, EN, GN, Q0, Q1, Q2, Q3, RN);

   input     D0, D1, D2, D3, EN, GN, RN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, delay_GN, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, 
		delay_D3, IQ3, IQN3, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, delay_RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, delay_RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, delay_RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, delay_RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);
	checkrs	i13 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);
	checkrs	i13 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRT8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit low active transparent D-latch with reset; tristate Q Buffer with active low 
//   enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRT8HDLLX1 (D0, D1, D2, D3, D4, D5, D6, D7, EN, GN, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN);

   input     D0, D1, D2, D3, D4, D5, D6, D7, EN, GN, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, delay_GN, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, 
		delay_D3, IQ3, IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7,
		 IQ7, IQN7, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, delay_RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, delay_RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, delay_RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, delay_RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, delay_D4, clock_i, 1'b1, delay_RN, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, delay_D5, clock_i, 1'b1, delay_RN, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, delay_D6, clock_i, 1'b1, delay_RN, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, delay_D7, clock_i, 1'b1, delay_RN, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);
	checkrs	i25 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);
      (RN +=> Q4) = (0.02, 0.02);
      (RN +=> Q5) = (0.02, 0.02);
      (RN +=> Q6) = (0.02, 0.02);
      (RN +=> Q7) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$setuphold(posedge GN &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, 
		c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, D4, clock_i, 1'b1, RN, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, D5, clock_i, 1'b1, RN, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, D6, clock_i, 1'b1, RN, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, D7, clock_i, 1'b1, RN, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);
	checkrs	i25 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);
      (RN +=> Q4) = (0.02, 0.02);
      (RN +=> Q5) = (0.02, 0.02);
      (RN +=> Q6) = (0.02, 0.02);
      (RN +=> Q7) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge GN &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG7);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLRTHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with reset; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLRTHDLLX1 (D, EN, GN, Q, RN);

   input     D, EN, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSHDLLX0 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSHDLLX1 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSHDLLX2 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSHDLLX4 (D, GN, Q, QN, SN);

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSQHDLLX0 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSQHDLLX1 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSQHDLLX2 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSQHDLLX4 (D, GN, Q, SN);

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLSTHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch with set; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLSTHDLLX1 (D, EN, GN, Q, SN);

   input     D, EN, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLT2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLT2HDLLX1 (D0, D1, EN, GN, Q0, Q1);

   input     D0, D1, EN, GN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, delay_GN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLT4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLT4HDLLX1 (D0, D1, D2, D3, EN, GN, Q0, Q1, Q2, Q3);

   input     D0, D1, D2, D3, EN, GN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, delay_GN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLT8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLT8HDLLX1 (D0, D1, D2, D3, D4, D5, D6, D7, EN, GN, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7);

   input     D0, D1, D2, D3, D4, D5, D6, D7, EN, GN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, delay_GN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, delay_D4, clock_i, 1'b1, 1'b1, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, delay_D5, clock_i, 1'b1, 1'b1, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, delay_D6, clock_i, 1'b1, 1'b1, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, delay_D7, clock_i, 1'b1, 1'b1, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$setuphold(posedge GN, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, D4, clock_i, 1'b1, 1'b1, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, D5, clock_i, 1'b1, 1'b1, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, D6, clock_i, 1'b1, 1'b1, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, D7, clock_i, 1'b1, 1'b1, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge GN, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLLTHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DLLTHDLLX1 (D, EN, GN, Q);

   input     D, EN, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 1ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY1HDLLX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.8, 0.7);
   endspecify


endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 1ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY1HDLLX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.84, 0.83);
   endspecify


endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 2ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY2HDLLX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (1.81, 1.57);
   endspecify


endmodule
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//*****************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 2ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY2HDLLX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (1.88, 1.87);
   endspecify


endmodule
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 4ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY4HDLLX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (3.3, 3.15);
   endspecify


endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 4ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY4HDLLX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (3.43, 3.67);
   endspecify


endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY8HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 8ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY8HDLLX0 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (6.91, 7.32);
   endspecify


endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DLY8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Delay Cell 8ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

module DLY8HDLLX1 (A, Q);

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (7.05, 7.73);
   endspecify


endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN2HDLLX0 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN2HDLLX1 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN2HDLLX2 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN2HDLLX4 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN3HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN3HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN3HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EN3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EN3HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO2HDLLX0 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO2HDLLX1 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO2HDLLX2 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO2HDLLX4 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO3HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO3HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO3HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : EO3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module EO3HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FAHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FAHDLLX0 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FAHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FAHDLLX1 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FAHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FAHDLLX2 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FAHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FAHDLLX4 (A, B, CI, CO, S);

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : HAHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module HAHDLLX0 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : HAHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module HAHDLLX1 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : HAHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module HAHDLLX2 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : HAHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

module HAHDLLX4 (A, B, CO, S);

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX0 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX12
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX12 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX1 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX2 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX3
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX3 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX4 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX6
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX6 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : INHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

module INHDLLX8 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX12
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX12 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX1 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX2 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX3
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX3 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX4 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX6
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX6 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITHHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITHHDLLX8 (A, E, Q);

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX12
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX12 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX1 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX2 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX3
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX3 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX4 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX6
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX6 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ITLHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ITLHDLLX8 (A, EN, Q);

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCNHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCNHDLLX0 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCNHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCNHDLLX1 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCNHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCNHDLLX2 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCNHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCNHDLLX4 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCPHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCPHDLLX0 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCPHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCPHDLLX1 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCPHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCPHDLLX2 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LGCPHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LGCPHDLLX4 (CLK, E, GCLK);

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCNHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCNHDLLX0 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCNHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCNHDLLX1 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCNHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCNHDLLX2 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCNHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCNHDLLX4 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCPHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCPHDLLX0 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCPHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCPHDLLX1 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCPHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCPHDLLX2 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSGCPHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSGCPHDLLX4 (CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCNHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCNHDLLX0 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCNHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCNHDLLX1 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCNHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCNHDLLX2 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCNHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCNHDLLX4 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCPHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCPHDLLX0 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCPHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCPHDLLX1 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCPHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCPHDLLX2 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LSOGCPHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LSOGCPHDLLX4 (CGOBS, CLK, E, GCLK, SE);

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2IHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2IHDLLX0 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2IHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2IHDLLX1 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2IHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2IHDLLX2 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2IHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2IHDLLX4 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2HDLLX0 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2HDLLX1 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2HDLLX2 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU2HDLLX4 (IN0, IN1, Q, S);

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4IHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4IHDLLX0 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4IHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4IHDLLX1 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4IHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4IHDLLX2 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4IHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4IHDLLX4 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4HDLLX0 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4HDLLX1 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4HDLLX2 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MU4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MU4HDLLX4 (IN0, IN1, IN2, IN3, Q, S0, S1);

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA22HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA22HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA22HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA22HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA22HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA22HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA22HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA22HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2I1HDLLX0 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2I1HDLLX1 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2I1HDLLX2 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2I1HDLLX4 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2HDLLX0 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2HDLLX1 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2HDLLX2 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA2HDLLX4 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I1HDLLX0 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I1HDLLX1 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I1HDLLX2 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I1HDLLX4 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I2HDLLX0 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I2HDLLX1 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I2HDLLX2 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3I2HDLLX4 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA3HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I1HDLLX0 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I1HDLLX1 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I1HDLLX2 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I1HDLLX4 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I2HDLLX0 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I2HDLLX1 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I2HDLLX2 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I2HDLLX4 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I3HDLLX0 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I3HDLLX1 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I3HDLLX2 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4I3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4I3HDLLX4 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA4HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I1HDLLX0 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I1HDLLX1 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I1HDLLX2 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I1HDLLX4 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I2HDLLX0 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I2HDLLX1 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I2HDLLX2 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I2HDLLX4 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I3HDLLX0 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I3HDLLX1 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I3HDLLX2 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I3HDLLX4 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I4HDLLX0 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I4HDLLX1 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I4HDLLX2 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5I4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5I4HDLLX4 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA5HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA5HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I1HDLLX0 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I1HDLLX1 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I1HDLLX2 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I1HDLLX4 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I2HDLLX0 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I2HDLLX1 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I2HDLLX2 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I2HDLLX4 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I3HDLLX0 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I3HDLLX1 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I3HDLLX2 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I3HDLLX4 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I4HDLLX0 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I4HDLLX1 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I4HDLLX2 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I4HDLLX4 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I5HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I5HDLLX0 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I5HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I5HDLLX1 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I5HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I5HDLLX2 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6I5HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6I5HDLLX4 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NA6HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NA6HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO22HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO22HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO22HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO22HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO22HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO22HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO22HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO22HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2I1HDLLX0 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2I1HDLLX1 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2I1HDLLX2 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2I1HDLLX4 (AN, B, Q);

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2HDLLX0 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2HDLLX1 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2HDLLX2 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO2HDLLX4 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I1HDLLX0 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I1HDLLX1 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I1HDLLX2 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I1HDLLX4 (AN, B, C, Q);

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I2HDLLX0 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I2HDLLX1 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I2HDLLX2 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3I2HDLLX4 (AN, BN, C, Q);

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO3HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I1HDLLX0 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I1HDLLX1 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I1HDLLX2 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I1HDLLX4 (AN, B, C, D, Q);

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I2HDLLX0 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I2HDLLX1 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I2HDLLX2 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I2HDLLX4 (AN, BN, C, D, Q);

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I3HDLLX0 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I3HDLLX1 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I3HDLLX2 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4I3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4I3HDLLX4 (AN, BN, CN, D, Q);

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO4HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I1HDLLX0 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I1HDLLX1 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I1HDLLX2 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I1HDLLX4 (AN, B, C, D, E, Q);

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I2HDLLX0 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I2HDLLX1 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I2HDLLX2 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I2HDLLX4 (AN, BN, C, D, E, Q);

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I3HDLLX0 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I3HDLLX1 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I3HDLLX2 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I3HDLLX4 (AN, BN, CN, D, E, Q);

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I4HDLLX0 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I4HDLLX1 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I4HDLLX2 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5I4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5I4HDLLX4 (AN, BN, CN, DN, E, Q);

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO5HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO5HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I1HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I1HDLLX0 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I1HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I1HDLLX1 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I1HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I1HDLLX2 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I1HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I1HDLLX4 (AN, B, C, D, E, F, Q);

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I2HDLLX0 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I2HDLLX1 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I2HDLLX2 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I2HDLLX4 (AN, BN, C, D, E, F, Q);

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I3HDLLX0 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I3HDLLX1 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I3HDLLX2 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I3HDLLX4 (AN, BN, CN, D, E, F, Q);

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I4HDLLX0 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I4HDLLX1 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I4HDLLX2 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I4HDLLX4 (AN, BN, CN, DN, E, F, Q);

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I5HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I5HDLLX0 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I5HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I5HDLLX1 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I5HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I5HDLLX2 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6I5HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6I5HDLLX4 (AN, BN, CN, DN, EN, F, Q);

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : NO6HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module NO6HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA211HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA211HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA211HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA211HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA211HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA211HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA211HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA211HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA21HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA21HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA21HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA21HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA21HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA21HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA21HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA21HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA221HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA221HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA221HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA221HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA221HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA221HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA221HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA221HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA222HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA222HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA222HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA222HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA222HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA222HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA222HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA222HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA22HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA22HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA22HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA22HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA22HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA22HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA22HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA22HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA311HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA311HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA311HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA311HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA311HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA311HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA311HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA311HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA31HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA31HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA31HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA31HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA31HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA31HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA31HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA31HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA321HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA321HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA321HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA321HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA321HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA321HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA321HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA321HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA32HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA32HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA32HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA32HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA32HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA32HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA32HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA32HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA33HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA33HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA33HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA33HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA33HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA33HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OA33HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OA33HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON211HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON211HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON211HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON211HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON211HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON211HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON211HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON211HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON21HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON21HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON21HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON21HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON21HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON21HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON21HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON21HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON221HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON221HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON221HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON221HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON221HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON221HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON221HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON221HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON222HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON222HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON222HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON222HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON222HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON222HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON222HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON222HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON22HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON22HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON22HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON22HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON22HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON22HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON22HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON22HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON311HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON311HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON311HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON311HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON311HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON311HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON311HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON311HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON31HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON31HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON31HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON31HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON31HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON31HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON31HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON31HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON321HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON321HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON321HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON321HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON321HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON321HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON321HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON321HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON32HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON32HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON32HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON32HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON32HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON32HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON32HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON32HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON33HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON33HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON33HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON33HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON33HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON33HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ON33HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ON33HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR2HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR2HDLLX0 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR2HDLLX1 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR2HDLLX2 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR2HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR2HDLLX4 (A, B, Q);

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR3HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR3HDLLX0 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR3HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR3HDLLX1 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR3HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR3HDLLX2 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR3HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR3HDLLX4 (A, B, C, Q);

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR4HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR4HDLLX0 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR4HDLLX1 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR4HDLLX2 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR4HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR4HDLLX4 (A, B, C, D, Q);

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR5HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR5HDLLX0 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR5HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR5HDLLX1 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR5HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR5HDLLX2 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR5HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR5HDLLX4 (A, B, C, D, E, Q);

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR6HDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR6HDLLX0 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR6HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR6HDLLX1 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR6HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR6HDLLX2 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : OR6HDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

module OR6HDLLX4 (A, B, C, D, E, F, Q);

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFHDLLX0 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFHDLLX1 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFHDLLX2 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFHDLLX4 (CN, D, Q, QN, SD, SE);

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFQHDLLX0 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFQHDLLX1 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFQHDLLX2 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFQHDLLX4 (CN, D, Q, SD, SE);

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRHDLLX0 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRHDLLX1 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRHDLLX2 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRHDLLX4 (CN, D, Q, QN, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRQHDLLX0 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRQHDLLX1 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRQHDLLX2 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRQHDLLX4 (CN, D, Q, RN, SD, SE);

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSHDLLX0 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSHDLLX1 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSHDLLX2 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSHDLLX4 (CN, D, Q, QN, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSQHDLLX0 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSQHDLLX1 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSQHDLLX2 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFRSQHDLLX4 (CN, D, Q, RN, SD, SE, SN);

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSHDLLX0 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSHDLLX1 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSHDLLX2 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSHDLLX4 (CN, D, Q, QN, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSQHDLLX0 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSQHDLLX1 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSQHDLLX2 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFFSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFFSQHDLLX4 (CN, D, Q, SD, SE, SN);

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFR2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFR2HDLLX1 (C, D0, D1, Q0, Q1, QN0, QN1, SD0, SD1, SE);

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, delay_SE);
	buf	i11 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, SE);
	buf	i11 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFR2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFR2HDLLX2 (C, D0, D1, Q0, Q1, QN0, QN1, SD0, SD1, SE);

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, delay_SE);
	buf	i11 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, SE);
	buf	i11 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFR4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFR4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, delay_SE);
	buf	i21 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, SE);
	buf	i21 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFR4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFR4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, delay_SE);
	buf	i21 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, SE);
	buf	i21 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFR8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFR8HDLLX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, delay_SE);
	buf	i41 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, SE);
	buf	i41 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFR8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFR8HDLLX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, delay_SE);
	buf	i41 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, SE);
	buf	i41 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRHDLLX0 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRHDLLX1 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRHDLLX2 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRHDLLX4 (C, D, Q, QN, SD, SE);

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQ2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQ2HDLLX1 (C, D0, D1, Q0, Q1, SD0, SD1, SE);

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, delay_SE);
	buf	i9 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, SE);
	buf	i9 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQ2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQ2HDLLX2 (C, D0, D1, Q0, Q1, SD0, SD1, SE);

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, delay_SE);
	buf	i9 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, SE);
	buf	i9 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQ4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQ4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, delay_SE);
	buf	i17 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, SE);
	buf	i17 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQ4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQ4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, delay_SE);
	buf	i17 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, SE);
	buf	i17 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQ8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQ8HDLLX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, delay_SE);
	buf	i33 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, SE);
	buf	i33 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQ8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQ8HDLLX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, delay_SE);
	buf	i33 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, SE);
	buf	i33 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQHDLLX0 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQHDLLX1 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQHDLLX2 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRQHDLLX4 (C, D, Q, SD, SE);

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRR2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRR2HDLLX1 (C, D0, D1, Q0, Q1, QN0, QN1, RN, SD0, SD1, SE);

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, delay_RN, 1'b1);
	not	i11 (SE_not, delay_SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, RN, 1'b1);
	not	i11 (SE_not, SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRR2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRR2HDLLX2 (C, D0, D1, Q0, Q1, QN0, QN1, RN, SD0, SD1, SE);

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, delay_RN, 1'b1);
	not	i11 (SE_not, delay_SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, RN, 1'b1);
	not	i11 (SE_not, SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRR4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRR4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, delay_RN, 1'b1);
	not	i21 (SE_not, delay_SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, RN, 1'b1);
	not	i21 (SE_not, SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRR4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRR4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, delay_RN, 1'b1);
	not	i21 (SE_not, delay_SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, RN, 1'b1);
	not	i21 (SE_not, SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRR8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRR8HDLLX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, delay_RN, 1'b1);
	not	i41 (SE_not, delay_SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, RN, 1'b1);
	not	i41 (SE_not, SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRR8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRR8HDLLX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, delay_RN, 1'b1);
	not	i41 (SE_not, delay_SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, RN, 1'b1);
	not	i41 (SE_not, SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRHDLLX0 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRHDLLX1 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRHDLLX2 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRHDLLX4 (C, D, Q, QN, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQ2HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQ2HDLLX1 (C, D0, D1, Q0, Q1, RN, SD0, SD1, SE);

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, delay_RN, 1'b1);
	not	i9 (SE_not, delay_SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, RN, 1'b1);
	not	i9 (SE_not, SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQ2HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQ2HDLLX2 (C, D0, D1, Q0, Q1, RN, SD0, SD1, SE);

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, delay_RN, 1'b1);
	not	i9 (SE_not, delay_SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, RN, 1'b1);
	not	i9 (SE_not, SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQ4HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQ4HDLLX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, delay_RN, 1'b1);
	not	i17 (SE_not, delay_SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, RN, 1'b1);
	not	i17 (SE_not, SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQ4HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQ4HDLLX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN, SD0, SD1, SD2, SD3, SE);

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, delay_RN, 1'b1);
	not	i17 (SE_not, delay_SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, RN, 1'b1);
	not	i17 (SE_not, SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQ8HDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQ8HDLLX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, delay_RN, 1'b1);
	not	i33 (SE_not, delay_SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, RN, 1'b1);
	not	i33 (SE_not, SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQ8HDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQ8HDLLX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, delay_RN, 1'b1);
	not	i33 (SE_not, delay_SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, RN, 1'b1);
	not	i33 (SE_not, SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQHDLLX0 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQHDLLX1 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQHDLLX2 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRQHDLLX4 (C, D, Q, RN, SD, SE);

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSHDLLX0 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSHDLLX1 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSHDLLX2 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSHDLLX4 (C, D, Q, QN, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSQHDLLX0 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSQHDLLX1 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSQHDLLX2 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRRSQHDLLX4 (C, D, Q, RN, SD, SE, SN);

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSHDLLX0 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSHDLLX1 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSHDLLX2 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSHDLLX4 (C, D, Q, QN, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSQHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSQHDLLX0 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSQHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSQHDLLX1 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSQHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSQHDLLX2 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SDFRSQHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

module SDFRSQHDLLX4 (C, D, Q, SD, SE, SN);

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : STEHDLLX0
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module STEHDLLX0 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : STEHDLLX1
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module STEHDLLX1 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : STEHDLLX2
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module STEHDLLX2 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : STEHDLLX4
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

module STEHDLLX4 (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SIGNALHOLDHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Leakage current compensator
//   last modified by : XLIB_PROC generated
//*****************************************************************

module SIGNALHOLDHDLL ( SIG );

   inout SIG;

   wire  n1;

// logic section  
  `ifdef DISPLAY_HOLD 
  
        buf i1 (n1, SIG);
        buf (pull1, pull0) i2 (SIG, n1);

     initial
     begin
      #0 $display("  > Warning: compiler directive DISPLAY_HOLD is set in cell");
         $display("  > %m");
         $display("  > SIGNALHOLD cell model is switched to provide logic levels");
         $display("  >  - danger of reading not really driven values ");    
         $display("  >  - undriven bus states are not detectable now ");    
         $display("  >");    
     end

  `else
// - no logic behaviour modelled for the electrical function of 
//   signalhold cell 
// - signalhold cell compensates leakage current only in case of
//   undriven node/bus and system stop
// - signalhold cell holds the bus bit on "0" or "1", but does not 
//   drive it, this is not in every case the same as the last valid 
//   logic value considering the desired application meaning
// - undriven bus bit should not be used as sequential element
// - reading from undriven bus_bit ("Z") has to provide ("X") in the
//   related block to detect such cases in simulation
//
// Use the compiler directive command
//   `define  DISPLAY_HOLD yes
// to enable the logic pullup/down behaviour of the Leakage current 
// compensator cell SIGNALHOLD*
//
     buf i3 (n1, SIG);
     bufif1 i4 (SIG, n1, 1'b0); /* always inactive */
  `endif
 
// no timing modelled for signalhold cell
// no backannotation possible for signalhold cell 
    
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : SIGNALHOLDDHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Leakage current compensator
//   last modified by : XLIB_PROC generated
//*****************************************************************

module SIGNALHOLDDHDLL ( SIG );

   inout SIG;

   wire  n1;

// logic section  
  `ifdef DISPLAY_HOLD 
  
        buf i1 (n1, SIG);
        buf (pull1, pull0) i2 (SIG, n1);

     initial
     begin
      #0 $display("  > Warning: compiler directive DISPLAY_HOLD is set in cell");
         $display("  > %m");
         $display("  > SIGNALHOLD cell model is switched to provide logic levels");
         $display("  >  - danger of reading not really driven values ");    
         $display("  >  - undriven bus states are not detectable now ");    
         $display("  >");    
     end

  `else
// - no logic behaviour modelled for the electrical function of 
//   signalhold cell 
// - signalhold cell compensates leakage current only in case of
//   undriven node/bus and system stop
// - signalhold cell holds the bus bit on "0" or "1", but does not 
//   drive it, this is not in every case the same as the last valid 
//   logic value considering the desired application meaning
// - undriven bus bit should not be used as sequential element
// - reading from undriven bus_bit ("Z") has to provide ("X") in the
//   related block to detect such cases in simulation
//
// Use the compiler directive command
//   `define  DISPLAY_HOLD yes
// to enable the logic pullup/down behaviour of the Leakage current 
// compensator cell SIGNALHOLD*
//
     buf i3 (n1, SIG);
     bufif1 i4 (SIG, n1, 1'b0); /* always inactive */
  `endif
 
// no timing modelled for signalhold cell
// no backannotation possible for signalhold cell 
    
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine


`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LOGIC0HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Constant logic 0
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LOGIC0HDLL (Q);

   output    Q;

// logic section:

// Function Q: 0
	buf	i0 (Q, 1'b0);

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LOGIC1HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Constant logic 1
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LOGIC1HDLL (Q);

   output    Q;

// logic section:

// Function Q: 1
	buf	i0 (Q, 1'b1);

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LOGIC0DHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Constant logic 0, DfM optimized, cross-talk optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LOGIC0DHDLL (Q);

   output    Q;

// logic section:

// Function Q: 0
	buf	i0 (Q, 1'b0);

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LOGIC1DHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Constant logic 1, DfM optimized, cross-talk optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LOGIC1DHDLL (Q);

   output    Q;

// logic section:

// Function Q: 1
	buf	i0 (Q, 1'b1);

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LOGIC0LVHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Constant logic 0, DfM optimized, cross-talk optimized for LV range
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LOGIC0LVHDLL (Q);

   output    Q;

// logic section:

// Function Q: 0
	buf	i0 (Q, 1'b0);

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : LOGIC1LVHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Constant logic 1, DfM optimized, cross-talk optimized for LV range
//   last modified by : XLIB_PROC generated
//****************************************************************************

module LOGIC1LVHDLL (Q);

   output    Q;

// logic section:

// Function Q: 1
	buf	i0 (Q, 1'b1);

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MPROBEBUHDLLX8
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Microprobe cell for buffered signal output (signal decoupling)
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MPROBEBUHDLLX8 (A);

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : MPROBEHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Micro probe cell for direct wire access
//   last modified by : XLIB_PROC generated
//****************************************************************************

module MPROBEHDLL (A);

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED1HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED1HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED2HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED2HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED3HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED3HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED5HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED5HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED7HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED7HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED10HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED10HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED15HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED15HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FEED25HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FEED25HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DECAP3HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DECAP3HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DECAP5HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DECAP5HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DECAP7HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DECAP7HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DECAP10HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DECAP10HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DECAP15HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DECAP15HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : DECAP25HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

module DECAP25HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE2HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE2HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE3HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE3HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE4HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE4HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE5HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE5HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE6HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE6HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE7HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE7HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE8HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE8HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE9HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE9HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE10HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE10HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE11HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE11HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE12HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE12HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE13HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE13HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE14HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE14HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE15HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE15HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE16HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE16HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE17HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE17HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE18HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE18HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE19HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE19HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE20HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE20HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE21HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE21HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE22HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE22HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE23HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE23HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE24HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE24HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE25HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE25HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE26HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE26HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE27HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE27HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE28HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE28HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE29HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE29HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE30HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE30HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE31HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE31HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNE32HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNE32HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED5HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED5HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED6HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED6HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED7HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED7HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED8HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED8HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED9HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED9HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED10HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED10HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED11HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED11HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED12HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED12HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED13HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED13HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED14HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED14HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED15HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED15HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED16HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED16HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED17HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED17HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED18HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED18HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED19HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED19HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED20HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED20HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED21HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED21HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED22HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED22HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED23HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED23HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED24HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED24HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED25HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED25HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED26HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED26HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED27HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED27HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED28HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED28HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED29HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED29HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED30HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED30HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED31HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED31HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : FCNED32HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

module FCNED32HDLL ();

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ANTENNACELLN2HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : protection cell against antenna effects (net charge) at manufacture, NIMP diode in 
//   substrate
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ANTENNACELLN2HDLL (A);

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ANTENNACELLNP2HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : protection cell against antenna effects (net charge) at manufacture, PIMP diode in 
//   NWELL, NIMP diode in substrate
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ANTENNACELLNP2HDLL (A);

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : ANTENNACELLP2HDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : protection cell against antenna effects (net charge) at manufacture, PIMP diode in 
//   NWELL
//   last modified by : XLIB_PROC generated
//****************************************************************************

module ANTENNACELLP2HDLL (A);

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine

`timescale 1ns/10ps
`celldefine
`suppress_faults
`enable_portfaults
//****************************************************************************
//   technology       : 180 nm HV SOI CMOS
//   module name      : CLKVBUFHDLL
//   version          : 1.3.0, Tue Apr 28 06:15:00 2020
//   cell_description : Virtual Clock Tree Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

module CLKVBUFHDLL (A, Q);

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule
//****************************************************************************
`nosuppress_faults
`disable_portfaults
`endcelldefine
